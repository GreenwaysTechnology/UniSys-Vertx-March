

Vert.X:

Vert.X Tech Stack:
..................

What is Java?

Object Oriented Programming
Functional Style/ pure Programming

Concurrency:
   1.Multi threading
   2.Event loop
     -Async Programming/Nonblocking

Reactive Programming

MicroServices
  Plain MicroServices apps
  Reactive Microservice 

//////////////////////////////////////////////////////////////////////////////////////////

Java :

   Technology, to build applications which is portable across multiple os.

How to build portable(Platform independent) Applications?
   JVM -  Java Virtual Machine

JVM
 VM - Virtual Machine

JVM APPLICATION VM,Which represents os abstraction.

Hard Virtualzation :Virtualize hardwares

On single os(Host),You can run many other os(Oracle VM)

Containerzation : How to build light weight VMs
 ->Docker
////////////////////////////////////////////////////////////////////////////////////////////

JVM internal architectures:
.........................
 JVM is c Program - java.c(source code)
   Binary Image :
   on windows : java.exe

Types of Programs:

1.Passive
   Programm which is hard disk.
   Programm which is not loaded on RAM
   Programm which is not accessed by CPU. 
2.Active 
  Program which is ram 
  Program which is accessed by CPU.

Note:
  Active Program we call "Process".
  Program in execution
  Program in Main Memory.
 

Any Program which is in RAM  has "Layout/Structure".


if you run program on another program
 eg : on jvm , running java program. ----->Sub Process / Thread.


Heap:
  The place where you can allocate memory for running programs.
   Active memory:

 Objects : active memory of class.=>new Class()=Active Memory



class OrderService{

 int orderId;

 public void placeOrder(){

 }

}
OrderService orderService=new OrderService()
orderService.placeOrder();
or.save()

You can run only one frame at the same time on single cpu.

stack frame /frame is other wise called as "thread".


Every Process uses "Multi frame architecture" - Multi threaded architecture.


Fundamental idea of webserver:

1.each client request is treated as "single Thread"
2.Web server creates thread,manages the life cycle of thread.



Evils of "Process Level Multi Threading":

1.Resource allocation : memory manangement
2.Dead Lock
3.Starvation
4.Race conditions

Solution to Process level multi threading;
..........................................''

Worker Level multi threading. 

Objective:

  Dont create,manage threads at Process level rather than "Delegate to OS Kernals"

 This is called as 

     "Non Blocking"
     "Async Programming"

//////////////////////////////////////////////////////////////////////////////////////////

Java and Async Programming:
............................
   What if jvm supports non-blocking,evented concurrency?


Java 7 called Dolphin

   Dolphin  introduced  experimental model for building fast  disk IO, called “NIO” – NonBlocking IO when compare to traditional IO.


That was beginning
      Due to low support  from Java, only DISK IO was implemented
Later it was improved, added TCP/IP IO was implemented 
 But it is still Not “Reactor Pattern Model”



Birth of Open Source Projects 
	to solve NON Blocking IO On JVM

NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns


 		      Netty
		         |
          	      nettycore
			 |
			nio
			 |
		        jvm

Netty project provides:
1.nio only for disk io but netty provided more io like
   tcp/ip,sockets,udp,http
  non blocking
 netty uses "Reactor Model" internnaly



Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library



 		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm


Vertx:


Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM. initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.

			
			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


NonBlocking IO Apis


                     NonBlocking IO Application
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM



Vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
		|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				 |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM
                                
          
///////////////////////////////////////////////////////////////////////////////////////////

Dont call us,we will call you ----- Event Driven programming



Req : to read database records

  Client----req -----Vertx---|---delegate db operations--db

					db operations done
					<--inform vertx 
				callbackFunctions---result




Vertx Tech Stack
  Build async,non blocking Apps

Spring is collection of projects called modules
  like core,data,mvc,integration,microservice.............

Like Spring Vertx is also collection projects

Vertx-core
vertx-web
Vertx-Data
Vertx-Reactive Extension
Vertx-Microservices
Vertx-Messaging
Vertx-Security
Vertx-Integration
Vertx-Devops Engineering
Vertx-Testing
Vertx-Clusters
Vertx-Services
Vertx-Cloud

Vertx-Core:

Writing TCP clients and servers
Writing HTTP clients and servers including support for WebSockets
The Event bus
Shared data - local maps and clustered distributed maps
Periodic and delayed actions
Deploying and undeploying Verticles
Datagram Sockets
DNS client
File system access
High availability
Native transports
Clustering   

////////////////////////////////////////////////////////////////////////////////////////

Does Vertx 100% NonBlocking Platform?
  Yes!, some of the API in Vertx is blocking  , particullary fs apis.


Vertx has event loop which is broker between processing unit and clients.

How many event loops available on vertx when compare to Node.js?

 Node has single event loop per instance.

But Vertx has many event many event loops , Per CPU 2 event loops.

           So that we can call "Mutli Core Reactor Pattern"

/////////////////////////////////////////////////////////////////////////////////////////////

Programming with Vertx:
........................

Vertx supports many programming languages. Each Programming pl has its own paradigm.

Vertx supports many paradigm:

1.Object Oriented Programming.

1.Abstraction
2.Encapsulation
3.Modularity
4.Typing
5.Hierachy
6.Conncurency
 7.Persistency

2.Functional Programming
3.Event Driven Programming
4.Reactive Programming
5.Actor Model driven Programming


Java PL 
  java is object oriented,functional style programming language.

When you select java in vertx.

 java + oo + functional + event driven + actor model + reactive

When you select javascript in vertx.

  javascript is object based,functional style,event driven pl.

pure vs style:

 if a language implements all principles then can be certified pure
 if not then "style"/"based"

 java is pure oo, functional style.
//////////////////////////////////////////////////////////////////////////////////////

java supports functional style programming principles from java 8 on wards.

In Vertx, programming building blocks are functional style.

.............................................................................................

Functional Programming principles  and implementation:
......................................................

1.Purly functional
  The language implements functional programming paradgims fully.
2.Functional style.
  The language partially implements functional programming concepts.



Functional programming is style of programming which modeled from Mathmetical concepts


History:

 Alonzo Church Proposed a model called "functions" to implement "computation model"
 where a Alan turing proposed a model called "State" machine.
 Church is phd student under alan turing.


Most of the functional and functional style lanaguages follows Chruch model called      
"Lambda Calculs"

Programming languages which implements lambda calculs:
 Haskell, JavaScript, Scala, Erlang, Lisp, ML, Clojure, OCaml, Common Lisp, Racket,Java 8,9,11,12.

Java 8 implements Lambda Calculs.

In lambda calculs we form program using function composition.

Object composition
  -we pass object to functions/methods
  -we create object in functions/methods
  -we return object from functions/methods

Function Composition:
 -we pass function to another functions as parameter
 -we create function in functions -nested function /closure
 -we return function from functions -



Principles of Functional Programming:



1.Pure functions
2.Recursion
3.Referential transparency
4.Functions are First-Class and can be Higher-Order
5.Variables are Immutable


1.Pure functions:
...............
  A. First, they always produce the same output for same arguments irrespective of 
   anything else.

  B. They have no side-effects.
      There are no statements or instructions, only expressions which cannot mutate variables (local or global) nor access state


   A.
   function  getStock(value){

        return value
   }

  getStock(10)=>10


  B. what if i have input , which need to be computed ,how to employ pure function?
 
   function updateCity(city,profile){


  }

 here city is value, profile is object to be updated


 String str="hello".trim()=>new Object.toUpperCase()=>new Object.operation().api().api().api()...... 

  based on builder/command chain pattern,

 In vertx we call "Fluent" api=>Pure function based



Functions are First-Class and can be Higher-Order:
-------------------------------------------------
 
  function test(callback){

    return function(){

   }
 }

 test(function(){});

/////////////////////////////////////////////////////////////////////////////////////////////

Programming Approch:

1.imperative

 -"tell what to do and also how to do it"
 -It uses statements
    ->collection of statments form program
    ->Each statement is executed in Sequence
    ->When each statement is executed which changes/mutate the state of machine(data/memory           location)
Impertive style programming based on "Alan turing State Machine"


Problem Statement:
 
   List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
 
  -find the total of double of even numbers

Problem Statement:
 
   List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
 
  -find the total of double of even numbers

import java.util.Arrays;
import java.util.List;

public class StateMutationImperative {
	public static void main(String[] args) {

		List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

		// find the total of double of even numbers
		int result = 0; // local state

		for (int e : numbers) {
			if (e % 2 == 0) { //
				result += e * 2; //mutate/update the state
			}
		}

		System.out.println(result);
	}

}




 List<String> names = Arrays.asList("Dory", "Gill", "Bruce", "Nemo", "Darla", "Marlin", "Jacques");
 
Problem statement : find Nemo.

  List<String> names = Arrays.asList("Dory", "Gill", "Bruce", "Nemo", "Darla", "Marlin", "Jacques");

		// imperative
		boolean found = false;

		// using for loop

		for (int i = 0; i < names.size(); i++) {
			if (names.get(i).equals("Nemo")) {
				found = true;
				break;
			}
		}

		//for each
		for (String name : names) {
			if (name.equals("Nemo")) {
				found = true;
				break;
			}
		}
		if (found)
			System.out.println("Nemo found");
		else
			System.out.println("Nemo not found");
		//
		 
	}

    


Problems with impertive programming:

1.developer may apply different alogrthim to get results.
2.this code may lead bugs
3.this code may lead peformance issues
4.we cant acheive common code practice regarding biz logics
5.So complex to maintain,read
6.Scallablity is very less

declarative: 
 tell what to do and *not* how to do it


Simple declarative: without functional programming


 List<String> names = Arrays.asList("Dory", "Gill", "Bruce", "Nemo", "Darla", "Marlin", "Jacques");

// declative
if (names.contains("Nemo"))
 System.out.println("Nemo found");
else
 System.out.println("Nemo not found");

2.declartive


 List<String> names = Arrays.asList("Dory", "Gill", "Bruce", "Nemo", "Darla", "Marlin", "Jacques");

 tell what to do and *not* how to do it

 names.filter(name=>name.equals("Nemo"))=>new Filtered List

numbers.filter(n=>n%2==0).map(n=>n*2).collect()


declarative is application of functional programming : functional composition,Pure function.

Vertx recommends functional style programming only.
////////////////////////////////////////////////////////////////////////////////////////////

Implementation of functional programming extension in java:Lambda Calculs Implementation:

Language: Java 8,9

Functional Interfaces:

To implement lambda calculs, java provides interface having single abstract method called
"SAM".

A functional interface is an interface that contains only one abstract method.

They can have only one functionality to exhibit. : Single Responsbility Principle

lambda expressions can be used to represent the instance of a functional interface

Inner classes :

1.Regular Inner Classes 
2.Method-local Inner Classes
3.Anonymous Inner Classes
4.Static Nested Classes.
 
    "Lamda expressions are implemented with help of innerclasses behind the scenes"


////////////////////////////////////////////////////////////////////////////////////////////

interface vs classes when to use?

interface for different famaily of classes, where as classes are used only one family


Use case : how to write functional programming : using interfaces.

package com.unisys.fp;

interface Greeter {
	String greet();
}

//how to implement Greeter interface?

//Way -1 : declaring class which implements Greeter
class GreeterImpl implements Greeter {

	public String greet() {
		// TODO Auto-generated method stub
		return "Hello";
	}

}

public class GreeterImplMain {
	public static void main(String[] args) {
		Greeter g = new GreeterImpl();
		System.out.println(g.greet());

		// way 2:
		Greeter welcome = new Greeter() {

			public String greet() {
				// TODO Auto-generated method stub
				return "Welcome";
			}
		};
		System.out.println(welcome.greet());

		Runnable runnable = new Runnable() {

			public void run() {
				// TODO Auto-generated method stub
				System.out.println(Thread.currentThread().getName());
			}
		};
		Thread thread = new Thread(runnable);
		thread.start();

		// Way 3 : Java 8 functional Programming Style

		Greeter mygreeter = () -> {
			return "Hello Lambda";
		};
		System.out.println(mygreeter.greet());

	}
}
/////////////////////////////////////////////////////////////////////////////////////////
Lambda Expression rules:

if you want to functional programming, java applies rules to make interface is functional.

1. interface must have only one method declaration : SAM : SRP

@FunctionalInterface
interface Welcome {
	void sayHello();
}

if you declare one method inside interfaces which becomes functional funciton but we must enable standards by using annotation.

package com.unisys.fp;

@FunctionalInterface
interface Welcome {
	void sayWelcome();
}

public class WelcomeFunctionalInterface {
	public static void main(String[] args) {

		Welcome welcome = () -> {
			System.out.println("SayHello");
		};
		welcome.sayWelcome();

	}
}
//////////////////////////////////////////////////////////////////////////////////////////

Code Refactoring:


Use case 1: if the lambda function contains only one line of code

//Use case 2 : if function having only one line of code.
		 //drop {}
		welcome = ()->System.out.println("SayHello");
		welcome.sayWelcome();


Args and Parameters:
....................

 void add(int a){


 }
 add(10)
 //10 params
 //a args

package com.unisys.fp;

@FunctionalInterface
interface Stock {
	void getValue(int a);
}

public class ParamsAndArgs {
	public static void main(String[] args) {

		Stock stock = null;

		//args
		stock = (int a) -> System.out.println("Stock Value " + a);

		stock.getValue(10); //param

	}
}


package com.unisys.fp;

@FunctionalInterface
interface Stock {
	void getValue(int a);
}

public class ParamsAndArgs {
	public static void main(String[] args) {

		Stock stock = null;

		// args
		stock = (int a) -> System.out.println("Stock Value " + a);

		stock.getValue(10); // param

		// type inference ; Arg type is understand based on parameter value

		stock = (a) -> System.out.println("Stock Value " + a);

		stock.getValue(30); // param

		// if arg is single variable, you can omit () as welcome
		stock = a -> System.out.println("Stock Value " + a);

		stock.getValue(30); // param
	}
}

///////////////////////////////////////////////////////////////////////////////////////////

Return values:

package com.unisys.fp;

@FunctionalInterface
interface Inventory {
	int getStockValue();
}

@FunctionalInterface
interface Product {
	int getQty(int qty);
}

public class LambdaReturnValues {
	public static void main(String[] args) {

		Inventory inv = null;
		inv = () -> {
			return 100;
		};
		System.out.println(inv.getStockValue());

		// nomore body only return statement:drop {}
		inv = () -> 100;
		System.out.println(inv.getStockValue());

		Product product = null;
		product = (int qty) -> {
			return qty;
		};
		System.out.println("Qty : " + product.getQty(10));

		// Args can be type inferenced
		product = (qty) -> {
			return qty;
		};
		System.out.println("Qty : " + product.getQty(10));
		// if arg is single drop ()
		product = qty -> {
			return qty;
		};
		System.out.println("Qty : " + product.getQty(10));
		// only one return statement : drop {} and return statement
		product = qty -> qty;
		System.out.println("Qty : " + product.getQty(10));

	}
}

/////////////////////////////////////////////////////////////////////////////////////////

How to pass functions as Parameter?

package com.unisys.fp;

@FunctionalInterface
interface Handler {
	void handle();
}

@FunctionalInterface
interface AsyncHandler {
	void handle(String connectionString);
}

class Connector {
	public void connect(Handler handler) {
		// call Hanlder handle mehtod
		handler.handle();
	}

	public void asynConnect(AsyncHandler handler) {
		handler.handle("host:localhost,port:8080");
	}
}

@FunctionalInterface
interface Resolver {
	void resolve(String message);
}

@FunctionalInterface
interface Rejection {
	void reject(String err);
}

class HttpServer {
	public void connect(Resolver resolver, Rejection rejection) {
		boolean isConnected = true;
		if (isConnected) {
			resolver.resolve("Http Server Connected : 200 ");
		} else {
			rejection.reject("Server Connection failed : 500");
		}

	}
}

public class MethodsAsParameter {
	public static void main(String[] args) {

		Connector connector = new Connector();
		// Passing implementation of interface as "method parameter inner class"
		connector.connect(new Handler() {

			@Override
			public void handle() {
				System.out.println("Connection is Ready!");
			}
		});
		// Lambda
		connector.connect(() -> {
			System.out.println("HTTP Connection is Ready");
		});
		connector.asynConnect(connectionInfo -> {
			System.out.println(connectionInfo);
		});
		//
		HttpServer http = new HttpServer();
		http.connect(r -> System.out.println(r), err -> System.out.println(err));

	}
}
//////////////////////////////////////////////////////////////////////////////////////////

Java Lambda Expressions #3 - Variable Capture


package com.unisys.fp;

@FunctionalInterface
interface Variable {
	void doIt();
}

public class VariableCaptureDemo {

	private int counter;

	// capaturing instance variables inside lambda
	public void increment() {
		Variable variable = () -> {
			System.out.println(++counter);
		};
		variable.doIt();
	}

	public static void main(String[] args) {
		new VariableCaptureDemo().increment();
		// Capaturing local variables inside lambda
		String name = "Subramanian";
		Variable variable = () -> {
			System.out.println(name);
		};
		variable.doIt();
	}
}
////////////////////////////////////////////////////////////////////////////////////////////

Method References:

package com.unisys.fp;
//passing instance method /static method as parameter to lambda

//interface takes input prints the same
@FunctionalInterface
interface Printer {
	void print(String var);
}

class MicroTaskExecutor {

	public static void startMicroTask() {
		for (int i = 0; i < 3; i++) {
			System.out.println(MicroTaskExecutor.class.getName() + "" + i);
		}
	}
}

class Loop {

	private void startMicroTask() {
		for (int i = 0; i < 5; i++) {
			System.out.println("micro task thread -" + i);
		}
	}

	public void startLoop() {
		Thread thread = null;
		thread = new Thread(new Runnable() {
			@Override
			public void run() {
				for (int i = 0; i < 5; i++) {
					System.out.println("thread-" + i);
				}
			}
		});
		thread.start();
		// lambda
		thread = new Thread(() -> {
			for (int i = 0; i < 5; i++) {
				System.out.println("thread-" + i);
			}
		});
		thread.start();
		// passing method as parameter
		thread = new Thread(() -> startMicroTask());
		thread.start();
		// passing method as parameter using : methodreference
		// this::methodName
		thread = new Thread(this::startMicroTask);
		thread.start();
		// Passing method from util class
		// methodReference className::methodName
		thread = new Thread(MicroTaskExecutor::startMicroTask);
		thread.start();

	}

}

public class MethodReferences {
	public static void main(String[] args) {
		Loop loop = new Loop();
		loop.startLoop();
		// How to simplfify taking input and print same

		Printer printer = null;
		printer = name -> {
			System.out.println(name);
		};
		printer.print("Subramanian");
		// using method referecence
		printer = System.out::println;
		printer.print("Geetha");

	}
}
////////////////////////////////////////////////////////////////////////////////////////////

I want to implement functional programming, i need functional interface but most the time
i may use like single input,output the same, two input , return the same .

for that use cases i need not maintain my own interfaces, java provides built in interfaces
for most of the use cases.


Why / Advantages of built in interfaces:
1.if you dont want to have your own functional interfaces for common tasks.

Java Provides lot of in built functional interfaces in the package 
java.util.function

Important functional interfaces:
...............................
1.Consumer
2.Predicate
3.Supplier
4.UnarOperator
5.BinaryOperator
6.Function

	        nothing->T            Supplier
		T->nothing            Consumer
		T->T                  UnaryOperator
		T,T->T                BinaryOperator
		S->T                  Function
		T->boolean            Predicate 


1.Consumer
  Represents an operation that accepts a single input argument and returns no result
package com.unisys.fp;

import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

public class BuiltinFunctionalInterfaces {
	public static void main(String[] args) {

		Consumer<String> consumer = null;
		consumer = new Consumer<String>() {
			@Override
			public void accept(String t) {
				System.out.println(t);

			}
		};
		consumer.accept("Hello");
		consumer = t -> System.out.println(t);
		consumer.accept("Hai");
		consumer = System.out::println;
		consumer.accept("Welcome");
		// consumer interface in list iteration
		List<String> names = Arrays.asList("Ram", "Subramanian", "Divya");
		names.forEach(name -> System.out.println(name));
		names.forEach(System.out::println);


	}
}
//////////////////////////////////////////////////////////////////////////////////////////////

                       Reactive Programming and implementation

What is Reactive?

	The Oxford dictionary defines reactive as “showing a response to a stimulus.”

Response: The Result 
Stimulus : trigger /actions : Events

So, reactive software reacts and adapts its behavior based on the stimuli it receives.

However, the responsiveness and adaptability promoted by this definition are programming challenges because the flow of computation isn’t controlled by the programmer but by
the stimuli.



What is Reactive Programming?
 
It is one of the Programming Paradigm.

It is hybrid Programming paradigm.
 
ReactiveProgramming = Observable Design Pattern + Iterator Design Pattern + Functional Programming principles + Event Driven Programming + Push based Programming.


The reactive programming paradigm is often presented in object-oriented languages 
   as an extension of the "Observer design pattern".

Observer Design Pattern implementation:

There are one to many relationship among objects

There are one to many relationship among objects

                          Owner/Subject/Producer
				 |
			         |
				 |
			Event Notification Interface
				 |
		-------------------------------------------------	
		|           	|               |         |
       Listeners               Listners      Listeners  Listeners
       subscribers 1..N


How do they communicate?
  By passing messages via method calls with intermediate object(Event)
      
Owner sends "stimuls/events" via notification interface to Listeners/Subscribers

Subscribers are notificated for an event, based on that event who will "react/respond"

Note: Reactive Programm extended with "Observer design pattern"  with more "events"

In general event always related to data : "Data Events".


Legacy "Observer design pattern" missed other events

  ->Errors : how to notify to subscribers incase some thing went wrong for "Producer"
  ->Completed : how to to notify the subscribes that "process" completed by "Producer".


****************************************************************************************

Iterator:
Iterator Design Pattern:

Pull Based and Push Based Programming:
.....................................

Pull Based: Iterator based

                                  Data Source(Array /List)
                                   (1,2,3,4,5,6,7,8,9,10)   Object

					 |
					
				Pull 1,Pull 2, Pull 3, Pull N....
							          
			   Iterator : Wrapper around for loop: Iterator Object
				   for-loop
			           for..in loop
	   
			

1.Stream emits items when consumer requests only


Iterator emits
 -Only data via iterator.next call
 -Errors via try...catch
 -No complete

Push Based Model:
.................
			         Data Source(Array /List)
                                   (1,2,3,4,5,6,7,8,9,10)   Object
				 	
				   1   2    3    4
				  push push push push
				 ---------------------------------
                       	  Stream      1  2  3 4 5 .... |
				 ----------------------------------
					| |        | |        |  | 
					| |        | |        |  | =>Event Channel
				    Data Event	 Error Event  Completed Event


				Subscriber/Listener


In reactive streams, the equivalent of the above pair is Publisher-Subscriber. But it is the Publisher that notifies the Subscriber of newly available values as they come, and this push aspect is the key to being reactive

*********************************************************************************************


3 .Reactive Programs are functional style based.

 if you want to process data streams, we need function style programming
 
 -Pure functions
 -Immutablity
 -Higher order functions: function composition
//////////////////////////////////////////////////////////////////////////////////////////////


                                       Streams 
   -----------------------------------------------------------------------------------------

What is Stream?

    Flow of data over period of time , from producer to consumer via "Event Channels".
    
    Stream is a Channel through which you send data.
       Data could be
                   Domain data
		   Error data
                   

Why Reactive Programming  / Applications of Reactive Programming:
.................................................................

                            "Data Processing"

 if you have large set of data, you dont want to load all the data in memory , you want to stream the data while streaming you want to process the data,consume processed data.


Types of Streams:


1.Up Stream

2.Down Stream


What is Reactive system? Reactive System specification:
.......................................................

Reactive Programming is more popular now a days. But when reactive programming came there was no standard body , to ensure /certify that the System is "fully Reactive".


To measure the system , what we have built, or going to build "Is Reactive".

The Specification was pubilshed in a web site.https://www.reactivemanifesto.org/


Principles:

1.Responsive:
  All Reactive systems  should respond Properly with respect to data,errors,completed.


2.Resilient: The ability to handle failure and recover

The system stays responsive in the face of failure. This applies not only to highly-available, mission-critical systems


3.Elastic: The ability to scale horizontally (scale out/in)

  The system stays responsive under varying workload. Reactive Systems can react to changes in the input rate by increasing or decreasing the resources allocated to service these inputs.


4.Message Driven:

	Reactive Systems rely on asynchronous message-passing to establish a boundary between components that ensures loose coupling, isolation and location transparency.
........................................................................................

                       Reactive Programming Implemenation



No Separate Reactive Programming language exists

Languages extends Reactive Programming principels via "Extensions/Plugins"

                    "ReactiveX"

Languages
	Java: RxJava
	JavaScript: RxJS
	C#: Rx.NET
	C#(Unity): UniRx
	Scala: RxScala
	Clojure: RxClojure
	C++: RxCpp
	Lua: RxLua
	Ruby: Rx.rb
	Python: RxPY
	Go: RxGo
	Groovy: RxGroovy
	JRuby: RxJRuby
	Kotlin: RxKotlin
	Swift: RxSwift
	PHP: RxPHP
	Elixir: reaxive
	Dart: RxDart

ReactiveX for platforms and frameworks
	RxNetty
	RxAndroid
	RxCocoa
        Project Reactor



ReactivX : Extension lib provides Reactive Programming

As a first step in the direction of reactive programming, Microsoft created the Reactive Extensions (Rx) library in the .NET ecosystem. 

Then RxJava implemented reactive programming on the JVM. As time went on, a standardization for Java emerged through the Reactive Streams effort, a specification that defines a set of interfaces and interaction rules for reactive libraries on the JVM.
/////////////////////////////////////////////////////////////////////////////////////////////
Lets Code:
..........

Project Setup:

1.Create Maven Project

 
pom.xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.unisys</groupId>
	<artifactId>javafpapp</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<dependencies>
		<!-- https://mvnrepository.com/artifact/io.reactivex.rxjava2/rxjava -->
		<dependency>
			<groupId>io.reactivex.rxjava2</groupId>
			<artifactId>rxjava</artifactId>
			<version>2.2.18</version>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.reactivestreams/reactive-streams -->
		<dependency>
			<groupId>org.reactivestreams</groupId>
			<artifactId>reactive-streams</artifactId>
			<version>1.0.3</version>
		</dependency>

	</dependencies>
</project>
/////////////////////////////////////////////////////////////////////////////////////////////

Rxjava Api Overview:


Objects:

1.Observable
2.Single
3.Subject
4.Scheduler

Apis(Methods):Pure functions,Which is based builder design pattern.

1.Operators
   Operators are technically methods/functions in reactive programming.


Observable:

 To Represent Stream.


Operators are classified based on usage

1.Creating Observables

   Creating Stream Objects based on factory design pattern.that means Objects are created
by factory apis.

   create:
	create an Observable from scratch by calling observer methods programmatically

   interval:
	Create Stream , which emits data based cpu clock.

2.Transforming Observables

   Converts source Stream(up Stream) into down stream after applying transformation.

   map

3.Filtering Observables

   Works based on "Prdicate" -booleans 

4.Combining Observables
   
   Merging many streams into single streams

   Zip

5.Error handling

  try
  Retry

6.Observable Utility Operators


7.Conditional and Boolean Operators

8.Mathematical and Aggregate Operators

9.Backpressure Operators

10.Connectable Observable Operators


////////////////////////////////////////////////////////////////////////////////////////////
Create Stream,emit data,complete:

package com.unisys.streams;

import io.reactivex.Observable;

public class GreeterObservable {
	public static void main(String[] args) {

		// create Stream from scratch
		Observable<String> stream = Observable.create(source -> {
			// Pushing Data into Stream
			source.onNext("Subramanian");
			source.onNext("Geetha");
			source.onNext("John");
			source.onNext("Arun");
			// im thinking i need to inform subscribe stream over
			source.onComplete();

		});

		// Subscribe the Stream : Three channels are ready now to get data,error,comple

//		stream.subscribe(data -> {
//			System.out.println(data);
//		}, err -> {
//			System.out.println(err);
//		}, () -> {
//			System.out.println("Stream done!");
//		});
		stream.subscribe(System.out::println, 
				System.out::println, () -> System.out.println("Stream done"));

	}
}

///////////////////////////////////////////////////////////////////////////////////////////

Use Builder Pattern:

package com.unisys.streams;

import io.reactivex.Observable;

public class NameStream {
	public static void main(String[] args) {

		// create Stream from scratch
		Observable.create(source -> {
			// Pushing Data into Stream
			source.onNext("Subramanian");
			source.onNext("Geetha");
			source.onNext("John");
			source.onNext("Arun");
			// im thinking i need to inform subscribe stream over
			source.onComplete();

		}).subscribe(System.out::println, System.out::println, () -> System.out.println("Stream done"));

	}
}
/////////////////////////////////////////////////////////////////////////////////////////////

How to push Error?

package com.unisys.streams;

import io.reactivex.Observable;

public class LoginStream {
	public static void main(String[] args) {
		// create Stream from scratch
		Observable.create(source -> {

			// biz logic
			String userName = "admin";
			String password = "adminxx";
			if (userName.equals(userName) && password.equals("admin")) {
				source.onNext("Login Success");
			} else {
				source.onError(new Exception("Login failed"));
			}

			// im thinking i need to inform subscribe stream over
			source.onComplete();

		}).subscribe(System.out::println, System.out::println, () -> System.out.println("Stream done"));

	}
}
//////////////////////////////////////////////////////////////////////////////////////////

How to push sequence of numbers?



package com.unisys.streams;

import io.reactivex.Observable;

public class SequenceStream {
	public static void main(String[] args) {
		// create Stream from scratch
		Observable.create(source -> {

			for (int i = 0; i < 10; i++) {
				source.onNext(i);
			}

			// im thinking i need to inform subscribe stream over
			source.onComplete();

		}).subscribe(System.out::println, System.out::println, () -> System.out.println("Stream done"));

	}
}
/////////////////////////////////////////////////////////////////////////////////////////////

How to transform items from one stream into another?
How to create upstream and downstream?

operator: map : transform each item into another item from source stream, will create down stream.

Use case: Multiply each item by 2.


up stream   ----1----2-----3----4-----5--|->
 	     map
  
down stream ----2----4-----6----8-----10--|->

            .subscribe


package com.unisys.streams;

import io.reactivex.Observable;

public class StreamTransformationUsingMap {

	public static void main(String[] args) {
		// create Stream from scratch
		Observable<Integer> stream = Observable.create(source -> {

			for (int i = 0; i < 10; i++) {
				source.onNext(i);
			}

			// im thinking i need to inform subscribe stream over
			source.onComplete();

		});
		stream.map(i -> i * 2).subscribe(System.out::println, System.out::println,
				() -> System.out.println("Stream done"));

	}

}
///////////////////////////////////////////////////////////////////////////////////////////

How to apply pridcate api: boolean expression

How to transform items from one stream into another and filter items?


operator: map,filter : transform each item into another item from source stream, will create down stream,filter and create

Use case: Multiply each item by 2.



up stream   ----1----2-----3----4-----5--|->
 	     map
  
down stream ----2----4-----6----8-----10--|->

            filter

down stream-------------------------------

            .subscribe



package com.unisys.streams;

import io.reactivex.Observable;

public class MapFilterStream {
	public static void main(String[] args) {

		// create Stream from scratch
		Observable<Integer> stream = Observable.create(source -> {

			for (int i = 0; i < 10; i++) {
				source.onNext(i);
			}

			// im thinking i need to inform subscribe stream over
			source.onComplete();

		});
		stream
		.map(i -> i * 3)
		.filter(i -> i % 2 == 0)
		.subscribe(System.out::println, System.out::println,
				() -> System.out.println("Stream done"));

	}
}
//////////////////////////////////////////////////////////////////////////////////////////////
How to create Stream from operators(factory methods)?
package com.unisys.streams;

package com.unisys.streams;

import java.util.Arrays;
import java.util.List;

import io.reactivex.Observable;

class Employee {
	private int id;
	private String name;

	public Employee() {
		// TODO Auto-generated constructor stub
	}

	public Employee(int id, String name) {
		super();
		this.id = id;
		this.name = name;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + "]";
	}

}

public class FactoryApiObservable {
	public static void main(String[] args) {

		Observable stream = null;
		// Just : sequence of values
		stream = Observable.just("Subramanian", "Ram", "Karthik", "Divya Sree");
		stream.subscribe(System.out::println, System.out::println, () -> System.out.println("done!"));

		// Array of elements : Array as datasource
		String[] names = { "A", "B", "C", "D", "C", "E" };
		// fromArray : convert array into Stream
		stream = Observable.fromArray(names);
		stream.subscribe(System.out::println, System.out::println, () -> System.out.println("done!"));

		Employee[] employees = { new Employee(1, "A1"), new Employee(2, "A2"), new Employee(3, "A3") };
		stream = Observable.fromArray(employees);
		stream.subscribe(System.out::println, System.out::println, () -> System.out.println("done!"));

		// List of elements : List as data Source
		List<String> nameList = Arrays.asList(names);
		stream = Observable.fromIterable(nameList);
		stream.subscribe(System.out::println, System.out::println, () -> System.out.println("done!"));
		List<Employee> empList = Arrays.asList(employees);
		stream = Observable.fromIterable(empList);
		stream.subscribe(System.out::println, System.out::println, () -> System.out.println("done!"));
	}
}
//////////////////////////////////////////////////////////////////////////////////////////


Broad casting:
.............

Producer(Stream)-----can be connected with ---one Subscriber : one to one
  This communication style is called "unicast".

Producer(Stream)----can be connected with ----->many subscribers : one to Many
  This communication style is called "Multicast".

Based on this communication style stream can be classified into two category.

1.Cold Observable(Cold Stream)
2.Hot Observable(Hot Stream)

1.Cold Observable

1.Observable that doesn’t emit items until a subscriber subscribes.
2.If we have more than one subscriber, then observable will 
emit sequence of items to all subscribers one by one.
3.Each subscriber get fresh copy of the data from the begining.
4.Most of Observerables are Cold.
package com.unisys.streams;

import io.reactivex.Observable;

public class ColdStream {

	public static void main(String[] args) throws InterruptedException {

		Observable<Integer> coldStream = Observable.create(subscriber -> {
			for (int i = 0; i <= 5; i++) {
				subscriber.onNext(i);
			}
			subscriber.onComplete();
		});
		// Subscriber : 1
		coldStream.subscribe(
				data -> System.out.println(" Subramanian's : " + data + " who is running in "
						+ Thread.currentThread().getName() + " thread"),
				System.out::println, () -> System.out.println("Subramanian done"));

		coldStream.subscribe(
				data -> System.out.println(
						" James " + data + " who is running in " + Thread.currentThread().getName() + " thread"),
				System.out::println, () -> System.out.println("James done"));
		Thread.sleep(5000);

		coldStream.subscribe(
				data -> System.out.println(
						" Geetha's " + data + " who is running in " + Thread.currentThread().getName() + " thread"),
				System.out::println, () -> System.out.println("Geetha done"));

	}

}
///////////////////////////////////////////////////////////////////////////////////////////
Hot Observable:

1.Observables that don’t wait for any subscription. They start emitting items   when created.
2.They don’t emit the sequence of items again for a new subscriber.
3.When an item is emitted by hot observable, all the subscribers that are   subscribed will get the emitted item at once.



There are many ways to implement hot observables:

1.ConnectableObservable
2.Subjects

1.ConnectableObservable:
  A ConnectableObservable is a single observable source for different observers.

A ConnectableObservable is a single observable source for different observers. The main difference aside from being a single observable source is that calling subscribe on a ConnectableObserver will not trigger emission, but connect will.



package com.unisys.streams;

import java.util.concurrent.TimeUnit;

import io.reactivex.Observable;
import io.reactivex.observables.ConnectableObservable;

public class HotStreamUsingConnectable {
	public static void main(String[] args) throws InterruptedException {

		// create Hold Stream
		Observable<Integer> coldstream = Observable.create(subscriber -> {
			for (int i = 0; i < 50; i++) {
				subscriber.onNext(i);
			}
		}); // Create Connectable Observable : Convert cold to Hot
		ConnectableObservable connectableObservable = coldstream.publish();

		System.out.println("Streaming begins");
		connectableObservable.subscribe(data -> {
			System.out.println("Subramanian : " + data);
		});
		connectableObservable.subscribe(data -> {
			System.out.println("Ram :  " + data);
		});

		Thread.sleep(50);
		connectableObservable.subscribe(data -> {
			System.out.println("................");

			System.out.println("John :  " + data);
		});

		connectableObservable.connect();
	}
}
///////////////////////////////////////////////////////////////////////////////////////

How to unsubscribe from the streaming?

Interval.

package com.unisys.streams;

import java.util.concurrent.TimeUnit;

import io.reactivex.Observable;
import io.reactivex.disposables.Disposable;
import io.reactivex.observables.ConnectableObservable;

public class HotWithUnSubscription {
	public static void main(String[] args) throws InterruptedException {

		// Cold Stream
		Observable<Long> coldStream = Observable.interval(1, TimeUnit.SECONDS);
		// HotStream
		Observable<Long> hotObservable = coldStream.publish().refCount();

		// Get the Reference of Disposable so that i can close the stream

		Disposable subu = hotObservable.doOnSubscribe(d -> System.out.println("Subramanian joined"))
				.doFinally(() -> System.out.println("Subramanian left"))
				.subscribe(item -> System.out.println("Subramanian Got Item : " + item));
		Thread.sleep(5000);

		Disposable ram = hotObservable.doOnSubscribe(d -> System.out.println("Ram joined"))
				.doFinally(() -> System.out.println("Ram left"))
				.subscribe(item -> System.out.println("Ram Got Item : " + item));

		Thread.sleep(3000);
		// ram wants to leave the stream
		ram.dispose();
	}
}
////////////////////////////////////////////////////////////////////////////////////////////

Subjects:
.........

 - create the hot observable from scratch

Types of Subjects:

1.AsyncSubject 
..............
 A.AsyncSubject will emit only the last value to its subscribers when source observable completes.
B.AsyncSubject will get all the items emitted by source observable but only emit the last item when source observable calls its onCompleted method.


package com.unisys.streams;

import io.reactivex.Observable;
import io.reactivex.subjects.AsyncSubject;

public class AsyncSubjectStream {
	public static void main(String[] args) {

		// Source Stream
		Observable<Integer> sourceStream = Observable.create(subscriber -> {
			for (int i = 0; i <= 20; i++) {
				subscriber.onNext(i);
			}
			subscriber.onComplete();
		});
		// Create Async Subject
		// AsyncSubject
		AsyncSubject<Integer> asyncSubject = AsyncSubject.create();
		// bind subject with source
		sourceStream.subscribe(asyncSubject);

		asyncSubject.subscribe(data -> {
			System.out.println("Subu's AsyncSubject Subject :" + data);
		}, err -> {
			System.out.println(err);
		}, () -> {
			System.out.println("Done!");
		});

		asyncSubject.subscribe(data -> {
			System.out.println("Ram's AsyncSubject Subject :" + data);
		}, err -> {
			System.out.println(err);
		}, () -> {
			System.out.println("Done!");
		});
	}
}
///////////////////////////////////////////////////////////////////////////////////////////

2.BehaviourSubject:
 
 BehaviourSubject emits the most recently item at the time of subscription or
 a default item if none has been emitted and then continues the sequence until complete.


package com.unisys.streams;

import java.util.concurrent.TimeUnit;

import io.reactivex.Observable;
import io.reactivex.subjects.BehaviorSubject;

public class BehaviourStream {

	private static void addSomeDelay() {
		try {
			System.out.println("Wait for some seconds");
			Thread.sleep(10000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		Observable<Long> coldb = Observable.interval(1000, TimeUnit.MILLISECONDS);
		BehaviorSubject<Long> behaviorSubject = BehaviorSubject.create();
		coldb.subscribe(behaviorSubject);
		addSomeDelay();
		behaviorSubject.subscribe(data -> {
			System.out.println("Subu's BehaviorSubject Subject :" + data);
		}, err -> {
			System.out.println(err);
		}, () -> {
			System.out.println("Done!");
		});
		behaviorSubject.subscribe(data -> {
			System.out.println("Ram's BehaviorSubject Subject :" + data);
		}, err -> {
			System.out.println(err);
		}, () -> {
			System.out.println("Done!");
		});
		addSomeDelay();

	}
}
/////////////////////////////////////////////////////////////////////////////////////////////


Single:
......
RxJava (and its derivatives like RxGroovy & RxScala) has developed an Observable variant called “Single.”

A Single is something like an Observable, but instead of emitting a series of values — anywhere from none at all to an infinite number — it always either emits one value or an error notification.

1.Single is an observable that emits only a single item.



Single.just("Hello World!").subscribe(System.out::println);
		Single single=Single.create(source -> {
			try {
				if ("hello".equals("hello")) {
					source.onSuccess("Hello");

				} else {
					throw new RuntimeException("some thing went wrong!");
				}
			} catch (RuntimeException e) {
				source.onError(e);

			}

		});
		single.subscribe(System.out::println, System.out::println);
		single.subscribe(System.out::println, System.out::println);

Maybe:

Maybe is similar to Single . but special Singles

only item: Maybe.just
only completed single: Maybe.empty
only error : Maybe.error

///////////////////////////////////////////////////////////////////////////////////////
Completable:

Objective:

only error
only complete
not data
package com.unisys.streams;

import java.util.concurrent.TimeUnit;

import io.reactivex.Completable;

public class CompletableStream {
	public static void main(String[] args) throws InterruptedException {

		Completable.complete().subscribe(() -> System.out.println("done!"));
		Thread.sleep(5000);

		Completable.complete().delay(1000, TimeUnit.MICROSECONDS).subscribe(() -> System.out.println("Time out"));
		Thread.sleep(5000);

	}

}
///////////////////////////////////////////////////////////////////////////////////////////

..........................................................................................

Reactive Streams:
................

Backpressure in RxJava comes into picture when you have an observable which emits items so fast that consumer can’t keep up with the flow leading to the existence of emitted but unconsumed items.

How unconsumed items, which are emitted by observables but not consumed by subscribers, are managed and controlled is what backpressure strategy deals with

Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure.

Since it requires system resources to handle backpressure, you need to choose right backpressure strategy that suits your requirement.


How to implement backpressure:


Back pressure Handling:

 1.Via Operators
 2.Via RXjava 2 /Java 9 Api Flowable===Observable
    Observable non-back pressure stream
    Flowable back-pressure powered stream.
 3.Via Project Reactor
      ->Flux === Observable ====Flowable



1.Via Operators:

Most of the Flitering Operaors are back pressure managed operators

 debounce,distinct,ElementAt,filter,first,ignoreElements,Last,sample,skip,skipLast,take,takeLast.

During backpressure, items may be droped
 drop operators: fliter
 collecting operators: window,buffer

Observable<Integer> observable = Observable.range(1, 200000).take(15);
		observable.subscribe(s -> {
			System.out.println("take first 15 " + s);
		});


Reactive Pull
..............
Above two strategies manage backpressure by dropping items, if your application need to process all the items emitted by source observable then you can’t use those strategies.

In this scenario, using reactive pull strategy is the right choice. In reactive pull, subscriber requests required number of items from observable by calling request().

In RxJava2, Flowable needs to be used to utilize reactive pull backpressure as observable in RxJava2 is non-backpressured.

package com.unisys.streams;

import io.reactivex.BackpressureStrategy;
import io.reactivex.Flowable;

public class FlowableBackPressure {
	public static void main(String[] args) {

		// Back pressure implementation: via buffer,drop elements
		Flowable<Integer> flowStream = Flowable.create(source -> {
			for (int i = 0; i < 2000; i++) {

				source.onNext(i);
			}
		}, BackpressureStrategy.BUFFER);// Buffers all onNext values until the downstream consumes it

		flowStream.subscribe((i) -> System.out.println("Item Got :" + i), System.out::println);
	}
}

Back Pressure with Hot : Hot Flowable : ConnectableFlowable
///////////////////////////////////////////////////////////////////////////////////////////

Vertx and Reactive Programming:
...............................

Vertx is non blocking, reactive microservice applications.

Can we use Reactive apis from rxjava2 directly inside Vertx?

Yes!, but Vert.x provides Rx-ified (using RxJava) versions for most of its APIs 
////////////////////////////////////////////////////////////////////////////////////////

                        -------------Vertx--------------------



Vertx is toolkit to build " Nonblocking/Async - Reactive - IO" Applications.

What is IO?

I - Input : read
O - Output : write

Types of IO:

1.File System:DISK IO
   
2.Network IO
3.IN Memomery
4.Process IO : IPC



1.File System:DISK IO
 Read and write data from and to local disk 

2.Network IO
   Building Network Applications: network applications are powered by protocals.

  TCP/IP,HTTP,HTTPS,UDP,SMTP.....

3.IN Memory

   Keeeping data in memory(ram): read and write.

4.Process IO : IPC : Event Bus

////////////////////////////////////////////////////////////////////////////////////////////

Core concepts of Vertx:

Vertx Represents single Object called "Vertx Instance"

io.vertx.core.Vertx
Interface Vertx

->The entry point into the Vert.x Core API.


Vertx Instance is an Which through which only you can build Application.

Vertx instance is Container Object /Context Object which contains all other objects and assets for application.

How to create Vertx Instance?

Vertx instance can be created using factory pattern
 factory apis are  
 A. vertx()
 B. vertx(io.vertx.core.VertxOptions) 
 C. clusteredVertx(io.vertx.core.VertxOptions, Handler)

The api are static methods inside "Vertx interface".

How to start vertx Programming:

Create / Get Vertx Instance 
............................

Ways:
1.create vertx instance via Vertx.vertx(); 

static Vertx	vertx()
  Creates a non clustered instance using default options.

Vertx vertx = Vertx.vertx();

package com.unisys.vertx.core;

import io.vertx.core.Vertx;

public class FirstVertxInstance {
	public static void main(String[] args) {

		// Get the Vertx Instance
		Vertx vertx = Vertx.vertx();

	}
}

2.create/Get Vertx instance via Verticles

What is verticle?

Refer : Actor model theory
   
 Vertical is "Reference implementation of Actor Model".


1.Verticles are chunks of code that get deployed and run by Vert.x. 

2.Verticles can be written in any of the languages that Vert.x supports and a single application can include verticles written in multiple languages.

3.You can think of a verticle as a bit like an actor in the Actor Model.

4.An application would typically be composed of many verticle instances running in the same Vert.x instance at the same time.

5. The different verticle instances communicate with each other by sending messages on the event bus.

*********************************************************************************************
Verticle,Vertx Relationship:
...........................


                        
			Verticle <-----> Verticle <----> Verticles
                                      Event Bus
			---------------------------------
				   Vertx Instance
					|
				       JVM



Deployment: in

   The process of Moving/installing Vertical on Vertx instance.


How to  create simple Vertical, how to deploy them?

Two ways

1.through Launcher which can be configured in pom.xml

  It is program, provided by vertx cli
 
 >mvn compile vertx:run

2.through Code.
public class FirstVertxInstance {
	public static void main(String[] args) {

		// Get the Vertx Instance
		Vertx vertx = Vertx.vertx();
		vertx.deployVerticle("com.unisys.vertx.core.HelloWorldVerticle");

	}
}



3.Deploying through vertx cli command:

E:\Lab\Session\unisys\vertx-01\src\main\java\com\unisys\core>vertx run MyVerticle.java
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
My Verticle is started
Succeeded in deploying verticle

////////////////////////////////////////////////////////////////////////////////////////////

Async Wrapper implementations:

io.vertx.core

1.Future:

Represents the result of an action that may, or may not, have occurred yet.

       AsyncResult                          Handler  -super interface				
       -----------------------------------------
			  |
			Future                       -Sub interface
				  

package com.unisys.vertx.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;

public class BasicFutureVerticle extends AbstractVerticle {

	// return the basic success future
	private Future<Void> getEmptyFuture() {
		Future future = Future.future();
		// invoke async completion event
		future.complete();
		return future;
	}

	// return the basic success future with payload(data)
	private Future<String> getDataFuture() {
		Future future = Future.future();
		// invoke async completion event
		future.complete("Hello Future!!!");
		return future;
	}
	// return the basic future with error

	private Future<String> getError() {
		Future future = Future.future();
		// invoke async completion event
		future.fail("Something went wrong!!!");
		return future;
	}

	// Future biz logic
	private Future<String> validate(String userName, String password) {
		Future future = Future.future();
		// biz logic
		if (userName.equals("admin") && password.equals("admin")) {
			future.complete("Login Successful : - " + userName);
		} else {
			future.fail("Login failed");
		}

		return future;
	}

	@Override
	public void start() throws Exception {

		Future future = null;
		future = getEmptyFuture();
		if (future.succeeded()) {
			System.out.println("Future succesfully returned");
		} else {
			System.out.println("Future not Returned");
		}
		// data future
		;
		// Grab the result of async operation
		getDataFuture().setHandler(new Handler<AsyncResult<String>>() {

			@Override
			public void handle(AsyncResult<String> event) {
				// TODO Auto-generated method stub
				if (event.succeeded()) {
					System.out.println(event.result());
				}
			}
		});
		// java Lambda Syntax
		getDataFuture().setHandler(h -> {
			if (h.succeeded()) {
				System.out.println(h.result());
			}
		});
		getDataFuture().onSuccess(new Handler<String>() {

			@Override
			public void handle(String event) {
				// TODO Auto-generated method stub
				System.out.println(event);
			}
		});
		getDataFuture().onSuccess(result -> System.out.println(result));
		getDataFuture().onSuccess(System.out::println);
		//////////////////
		System.out.println("Error Handling");
		getError().setHandler(h -> {
			if (h.failed()) {
				System.out.println(h.cause());
			}
		});
		getError().onFailure(System.out::println);
		// Validate
		validate("admin", "admin").setHandler(h -> {
			String r = h.succeeded() ? h.result() : h.cause().toString();
			System.out.println(r);
		});
	}

}
///////////////////////////////////////////////////////////////////////////////////////////

IS future is Async /Non blocking?
.................................


Future is not Async, but Future is Async Wrapper to handle async results(Success/failure).
 
 Future is Object which wraps the Results :  Future is "Decorator Object"

What could be async stuff in Vertx?
 
1.Timers

2.All IO apis
  tcp/ip,http,udp,database client apis.....


package com.unisys.vertx.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;

public class TimerAsyncFutureVerticle extends AbstractVerticle {

	private Future<String> blockingFuture() {
		Future future = Future.future();
		future.complete("Blocking future!!!");
		return future;
	}

	// async api
	private Future<String> delay(long time, String message) {
		Future future = Future.future();
		// trigger async call
		vertx.setTimer(time, h -> {
			future.complete(message);
		});
		return future;
	}

	@Override
	public void start() throws Exception {

		blockingFuture().setHandler(h -> {
			String r = h.succeeded() ? h.result() : h.cause().toString();
			System.out.println(r);
		});
		delay(1000, "Hai-1000").setHandler(h -> {
			String r = h.succeeded() ? h.result() : h.cause().toString();
			System.out.println(r);
		});
		blockingFuture().setHandler(h -> {
			String r = h.succeeded() ? h.result() : h.cause().toString();
			System.out.println(r);
		});

		delay(5000, "Hello-5000").setHandler(h -> {
			String r = h.succeeded() ? h.result() : h.cause().toString();
			System.out.println(r);

		});
		blockingFuture().setHandler(h -> {
			String r = h.succeeded() ? h.result() : h.cause().toString();
			System.out.println(r);
		});
	}
}










         